import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Cron, CronExpression } from '@nestjs/schedule';
import { startOfDay, endOfDay, addDays, differenceInDays } from 'date-fns';

export interface CreateNotificationDto {
  title: string;
  message: string;
  type: 'INFO' | 'WARNING' | 'ERROR' | 'SUCCESS';
  priority?: 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
  category: string;
  relatedId?: number;
  relatedType?: string;
  metadata?: any;
  userId?: number;
  autoGenerated?: boolean;
  ruleId?: number;
}

export interface CreateNotificationRuleDto {
  name: string;
  description?: string;
  triggerType: string;
  category: string;
  conditions: any;
  targetUsers: number[];
  frequency?: string;
  isActive?: boolean;
}

@Injectable()
export class NotificationsService {
  private readonly logger = new Logger(NotificationsService.name);

  constructor(private prisma: PrismaService) {}

  // ===== M√âTODOS B√ÅSICOS SIMPLIFICADOS =====
  
  async createNotification(data: CreateNotificationDto) {
    try {
      return await (this.prisma as any).notification.create({
        data: {
          title: data.title,
          message: data.message,
          type: data.type,
          priority: data.priority || 'NORMAL',
          category: data.category,
          relatedId: data.relatedId,
          relatedType: data.relatedType,
          metadata: data.metadata,
          userId: data.userId,
          autoGenerated: data.autoGenerated || false,
          ruleId: data.ruleId,
        },
        include: {
          user: true,
          rule: true,
        },
      });
    } catch (error) {
      this.logger.error('Error creando notificaci√≥n:', error);
      throw error;
    }
  }

  async getNotificationsForUser(
    userId: number,
    limit: number = 50,
    includeRead: boolean = true,
    includeArchived: boolean = false,
  ) {
    try {
      return await (this.prisma as any).notification.findMany({
        where: {
          OR: [
            { userId },
            { userId: null }, // Notificaciones broadcast
          ],
          isRead: includeRead ? undefined : false,
          isArchived: includeArchived ? undefined : false,
        },
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'desc' },
        ],
        take: limit,
        include: {
          rule: true,
        },
      });
    } catch (error) {
      this.logger.error('Error obteniendo notificaciones:', error);
      return [];
    }
  }

  async markAsRead(notificationId: number, userId: number) {
    try {
      return await (this.prisma as any).notification.updateMany({
        where: {
          id: notificationId,
          OR: [{ userId }, { userId: null }],
          isRead: false,
        },
        data: {
          isRead: true,
          readAt: new Date(),
        },
      });
    } catch (error) {
      this.logger.error('Error marcando como le√≠da:', error);
      throw error;
    }
  }

  async markAllAsRead(userId: number) {
    try {
      return await (this.prisma as any).notification.updateMany({
        where: {
          OR: [{ userId }, { userId: null }],
          isRead: false,
        },
        data: {
          isRead: true,
          readAt: new Date(),
        },
      });
    } catch (error) {
      this.logger.error('Error marcando todas como le√≠das:', error);
      throw error;
    }
  }

  async archiveNotification(notificationId: number, userId: number) {
    try {
      return await (this.prisma as any).notification.updateMany({
        where: {
          id: notificationId,
          OR: [{ userId }, { userId: null }],
        },
        data: {
          isArchived: true,
          archivedAt: new Date(),
        },
      });
    } catch (error) {
      this.logger.error('Error archivando notificaci√≥n:', error);
      throw error;
    }
  }

  async getUnreadCount(userId: number): Promise<number> {
    try {
      return await (this.prisma as any).notification.count({
        where: {
          OR: [{ userId }, { userId: null }],
          isRead: false,
          isArchived: false,
        },
      });
    } catch (error) {
      this.logger.error('Error obteniendo conteo:', error);
      return 0;
    }
  }

  // ===== GESTI√ìN DE REGLAS =====

  async createNotificationRule(data: CreateNotificationRuleDto) {
    try {
      return await (this.prisma as any).notificationRule.create({
        data,
      });
    } catch (error) {
      this.logger.error('Error creando regla:', error);
      throw error;
    }
  }

  async getNotificationRules() {
    try {
      return await (this.prisma as any).notificationRule.findMany({
        orderBy: { createdAt: 'desc' },
      });
    } catch (error) {
      this.logger.error('Error obteniendo reglas:', error);
      return [];
    }
  }

  async updateNotificationRule(id: number, data: Partial<CreateNotificationRuleDto>) {
    try {
      return await (this.prisma as any).notificationRule.update({
        where: { id },
        data,
      });
    } catch (error) {
      this.logger.error('Error actualizando regla:', error);
      throw error;
    }
  }

  async deleteNotificationRule(id: number) {
    try {
      return await (this.prisma as any).notificationRule.delete({
        where: { id },
      });
    } catch (error) {
      this.logger.error('Error eliminando regla:', error);
      throw error;
    }
  }

  // ===== GENERACI√ìN AUTOM√ÅTICA SIMPLIFICADA =====

  @Cron(CronExpression.EVERY_HOUR)
  async checkAutomaticNotifications() {
    this.logger.log('Ejecutando verificaci√≥n autom√°tica de notificaciones...');

    try {
      // Verificaciones b√°sicas de stock bajo
      await this.checkStockLow();
      await this.checkStockOut();
      await this.checkPaymentsDue();
    } catch (error) {
      this.logger.error('Error en verificaci√≥n autom√°tica:', error);
    }
  }

  private async checkStockLow() {
    try {
      const productsLowStock = await this.prisma.product.findMany({
        where: {
          AND: [
            { stock: { lte: 5 } },
            { stock: { gt: 0 } },
          ],
        },
        include: { category: true },
      });

      for (const product of productsLowStock) {
        // Verificar si ya existe una notificaci√≥n reciente
        const recentNotification = await (this.prisma as any).notification.findFirst({
          where: {
            category: 'STOCK',
            relatedId: product.id,
            relatedType: 'PRODUCT',
            createdAt: { gte: startOfDay(new Date()) },
          },
        });

        if (!recentNotification) {
          await this.createNotification({
            title: 'Stock Bajo',
            message: `El producto "${product.name}" tiene stock bajo (${product.stock} unidades)`,
            type: 'WARNING',
            priority: 'HIGH',
            category: 'STOCK',
            relatedId: product.id,
            relatedType: 'PRODUCT',
            metadata: {
              currentStock: product.stock,
              minStock: product.minStock,
              category: product.category.name,
            },
            autoGenerated: true,
          });
        }
      }
    } catch (error) {
      this.logger.error('Error verificando stock bajo:', error);
    }
  }

  private async checkStockOut() {
    try {
      const productsOutOfStock = await this.prisma.product.findMany({
        where: { stock: { lte: 0 } },
        include: { category: true },
      });

      for (const product of productsOutOfStock) {
        const recentNotification = await (this.prisma as any).notification.findFirst({
          where: {
            category: 'STOCK',
            relatedId: product.id,
            relatedType: 'PRODUCT',
            message: { contains: 'sin stock' },
            createdAt: { gte: startOfDay(new Date()) },
          },
        });

        if (!recentNotification) {
          await this.createNotification({
            title: '‚ùå Sin Stock',
            message: `El producto "${product.name}" est√° sin stock`,
            type: 'ERROR',
            priority: 'CRITICAL',
            category: 'STOCK',
            relatedId: product.id,
            relatedType: 'PRODUCT',
            autoGenerated: true,
          });
        }
      }
    } catch (error) {
      this.logger.error('Error verificando stock agotado:', error);
    }
  }

  private async checkPaymentsDue() {
    try {
      // Ventas pendientes de pago
      const salesDue = await this.prisma.sale.findMany({
        where: {
          isPaid: false,
          date: { lte: addDays(new Date(), -3) },
        },
        include: { client: true },
      });

      for (const sale of salesDue) {
        const daysPastDue = differenceInDays(new Date(), sale.date);
        
        await this.createNotification({
          title: 'üí∞ Pago Vencido',
          message: `Venta #${sale.id} vencida hace ${daysPastDue} d√≠as. Cliente: ${sale.client?.name || 'Sin cliente'}. Monto: $${sale.totalAmount}`,
          type: 'WARNING',
          priority: 'HIGH',
          category: 'PAGOS',
          relatedId: sale.id,
          relatedType: 'SALE',
          metadata: {
            daysPastDue,
            amount: sale.totalAmount,
            clientName: sale.client?.name,
          },
          autoGenerated: true,
        });
      }
    } catch (error) {
      this.logger.error('Error verificando pagos vencidos:', error);
    }
  }

  // ===== M√âTODOS DE UTILIDAD =====

  async createDefaultRules() {
    try {
      const adminUsers = await this.prisma.user.findMany({
        where: {
          roles: {
            some: {
              role: {
                name: 'ADMIN',
              },
            },
          },
        },
      });
      
      const adminUserIds = adminUsers.map(u => u.id);

      // Verificar si ya existen las reglas
      const existingRules = await (this.prisma as any).notificationRule.findMany({
        where: {
          name: {
            in: ['Stock Bajo', 'Stock Cr√≠tico', 'Sin Stock', 'Pagos Vencidos'],
          },
        },
      });

      const existingRuleNames = existingRules.map(r => r.name);

      // Crear reglas b√°sicas si no existen
      if (!existingRuleNames.includes('Stock Bajo')) {
        await (this.prisma as any).notificationRule.create({
          data: {
            name: 'Stock Bajo',
            description: 'Notifica cuando productos tienen stock bajo',
            triggerType: 'STOCK_LOW',
            category: 'STOCK',
            conditions: { threshold: 5 },
            targetUsers: adminUserIds,
            frequency: 'DAILY',
          },
        });
      }

      this.logger.log('Reglas por defecto procesadas exitosamente');
    } catch (error) {
      this.logger.error('Error creando reglas por defecto:', error);
    }
  }
}
